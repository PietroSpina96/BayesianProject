gra=rep(gra,10)
#x11()
#curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
for(j in 1:200){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
gra=gray(1:100/100)
gra=rep(gra,10)
x11()
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
for(j in 1:200){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
######### Comparison of simulated trajectories among 3 different values of a
##
a=0.5
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
x11()
par(mfrow=c(1,3))
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=0.5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
x11()
par(mfrow=c(1,3))
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=0.5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=5
M <- 750 # truncation level   M=500
Y <- vector(length=M) ## beta proportions in the stick breaking construction
tau <-  vector(length=M) ## support points
V <- vector(length=M)
# Simulation
Y <- rbeta(M,1,a) #simulation of the beta rvs
tau <- rnorm(M,0,1) # tau_i iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##summation of the weights V
V <- V/sum(V)  ## Rinormalization of the weights
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=50
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=50")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){    #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T,xlab="",ylab="",cex.axis=1.5)
a=1
M <- 100 # livello di troncamento   M=30
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)
round(V,4)
n=10 ## sample size
theta<-vector(length=n)
index <-vector(length=n)
for(j in 1:n){
index[j] <- sample(1:M,size=1,prob=V)
theta[j]=tau[index[j]]
}
index
theta
unique(theta)
#########################################################################################
### We could simulate a sample from a Dirichlet process X_1,...,X_n by
### (i) first simulating a (truncated) stick-breaking trajectory of a Dirichlet process P
### (ii) then simulating X_1,...,X_n
### as ABOVE.
### However, we could use a DIRECT sampling scheme
### GENERALIZED POLYA URN
###################################################################################
a=1  #0.1, 1,  100
n=10 ## sample size ##n=2, 10, 100, 697
theta<-vector(length=n) #simulated values: I rename it theta instead than X
theta[1] <- rnorm(1) #first simulated value from alpha_0 = N(0,1)
for(j in 2:n){ ## from the second simulated value, we get
w0<- a/(j-1+a) ## a NEW observation from alpha_0 with probability w0
w1<-rep(1/(j-1+a),j-1) ## or an OLD observation, each of the old obs with prob w1
index <- sample(0:(j-1),size=1,prob=c(w0,w1))
# Sample the index from a discrete distribution with weights
#   contained in the vector prob, i.e. sample from the categorical distr.
if(index==0){
theta[j] <- rnorm(1) # NEW observation
}
else{
theta[j]=theta[index] # OLD observation
}
}
theta
unique(theta)
# K_n: number of UNIQUE values in the sample theta
k <- length(unique(theta))
k
k <- vector(length=5000)
set.seed(19)
for(i in 1:5000){ ##Sampling from the generalized Polya urn repeatedly
##################################
##################################
theta[1] <- rnorm(1)
for(j in 2:n){
w0<-a/(j-1+a)
w1<-rep(1/(j-1+a),j-1)
index <- sample(0:(j-1),size=1,prob=c(w0,w1))
if(index==0){
theta[j] <- rnorm(1)
}
else{
theta[j]=theta[index]
}
}
###########################
###########################
k[i] <- length(unique(theta))
}
k
ymax=max(table(k)/5000)+0.01
x11()
plot(table(k)/5000,ylim=c(0,ymax),ylab="")
title("Prior probability of the number of clusters")
#### NON chiudere la finestra grafica
### SIMULATION
set.seed(13)  # fisso il seme aleatorio
Y <- rbeta(M,1,a) #simulated values of the M rvs which are beta(1,a)-distributed
tau <- rnorm(M,0,1) # simulated tau_i, iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod   ## V_i = Y_i \prod_{j=1}^{i-1}(1-Y_j)
## "spezzo i bastoncini" utilizzando le M v.a. Y_i prima simulate
print(sum(V))  ## Compute the sum of all weights so far
V <- V/sum(V)  ## Rinormalization of the weights (needed because truncation of the infinite series)
a=1 ##### TOTAL MASS parameter
M <- 1000 # truncation level   M=1000 o M=500
Y <- vector(length=M)    ## Y is the vector of the beta proportions in the stick-breaking
tau <-  vector(length=M) ## support points of the DP (theta_i at the blackboard)
V <- vector(length=M)    ## V is the vector of the weights of the support points tau_i
### SIMULATION
set.seed(13)  # fisso il seme aleatorio
Y <- rbeta(M,1,a) #simulated values of the M rvs which are beta(1,a)-distributed
tau <- rnorm(M,0,1) # simulated tau_i, iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod   ## V_i = Y_i \prod_{j=1}^{i-1}(1-Y_j)
## "spezzo i bastoncini" utilizzando le M v.a. Y_i prima simulate
print(sum(V))  ## Compute the sum of all weights so far
V <- V/sum(V)  ## Rinormalization of the weights (needed because truncation of the infinite series)
x11()
curve(dnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,ylim=c(0,0.5),xlab=" ",ylab="",cex.axis=1.5) #mean parameter alpha_0 (in magenta)
abline(h=0,lty=2)
lines(tau,V,"h",lwd=3,col="red")
title("Weights and support points for a simulated trajectory of a DP")
x11()
curve(dnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,ylim=c(0,0.5),xlab="alpha_0",ylab="",cex.axis=1.5) abline(h=0,lty=2)
lines(tau,V,"h",lwd=3,col="red")
title("Weights and support points for a simulated trajectory of a DP")
x11()
curve(dnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,ylim=c(0,0.5),xlab="alpha_0",ylab="",cex.axis=1.5)
abline(h=0,lty=2)
lines(tau,V,"h",lwd=3,col="red")
title("Weights and support points for a simulated trajectory of a DP")
x11()
curve(dnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,ylim=c(0,0.5),xlab="alpha_0",ylab="",cex.axis=1.5)
abline(h=0,lty=2)
lines(tau,V,"h",lwd=3,col="red")
title("Weights and support points for a simulated trajectory of a DP")
x11()
curve(dnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,ylim=c(0,0.5),xlab=" ",ylab="",cex.axis=1.5) #mean parameter alpha_0 (in magenta)
abline(h=0,lty=2)
lines(tau,V,"h",lwd=3,col="red")
title("Weights and support points for a simulated trajectory of a DP")
sort(V) # When a is SMALL, there is one SINGLE LARGE weight (about 1);
X11()
oth <- order(tau)
#postscript("trajectories_a1.eps")
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab=" ",ylab="",cex.axis=1.5) # in magenta la f.r. di alpha_0, la misura media
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Simulated trajectory of the DP distribution function")
a=0.5
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
a=0.5
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
#postscript("comparison.eps")
x11()
par(mfrow=c(1,3))
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=0.5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
a=5
M <- 750 # truncation level   M=500
Y <- vector(length=M) ## beta proportions in the stick breaking construction
tau <-  vector(length=M) ## support points
V <- vector(length=M)
# Simulation
Y <- rbeta(M,1,a) #simulation of the beta rvs
tau <- rnorm(M,0,1) # tau_i iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##summation of the weights V
V <- V/sum(V)  ## Rinormalization of the weights
a=0.5
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
#postscript("comparison.eps")
x11()
par(mfrow=c(1,3))
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=0.5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=5
M <- 750 # truncation level   M=500
Y <- vector(length=M) ## beta proportions in the stick breaking construction
tau <-  vector(length=M) ## support points
V <- vector(length=M)
# Simulation
Y <- rbeta(M,1,a) #simulation of the beta rvs
tau <- rnorm(M,0,1) # tau_i iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##summation of the weights V
V <- V/sum(V)  ## Rinormalization of the weights
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=50
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=50")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){    #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T,xlab="",ylab="",cex.axis=1.5)
a=1
M <- 100 # livello di troncamento   M=30
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)
round(V,4)
n=10 ## sample size
theta<-vector(length=n)
index <-vector(length=n)
for(j in 1:n){
index[j] <- sample(1:M,size=1,prob=V)
theta[j]=tau[index[j]]
}
index
theta
unique(theta)
help("sample")
# Commentate i set delle directory non vostre
#setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati")
#setwd('C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/potenziali_evocati')
setwd("C:/Users/admin/Documents/R/Project_BS/BayesianProject") #GiuliaR
load('functional_WP.RData')
library(fda.usc)
library(fda)
library(fields)
n <- 26
t_points <- 1600
X_bar <- colMeans(f.data$ausxSL$data) # functional mean
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
kernel_estimator(f.data$ausxSL$data,X_bar,n,1,9,t_points) # prova
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(t_points, X_bar, type = 'l', lwd=3, col = 'firebrick2')
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(t(t_points), X_bar, type = 'l', lwd=3, col = 'firebrick2')
View(data)
View(f.data)
setwd("C:/Users/admin/Documents/R/Project_BS/BayesianProject") #GiuliaR
help(linspace)
