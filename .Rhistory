alpha <- 1e+4
f.data_alpha <- matrix(0, nrow = 26, ncol = 1600)
for (i in 1:26){
for (j in 1:1600){
f.data_alpha[i,j] <- f_alpha_approx(f.data$ausxSL$data[i,j],1e+4,lambda,eigenft)
}
}
for (i in 1:26){
f.data_alpha[i,] <- f_alpha_approx(f.data$ausxSL$data[i,],alpha,lambda,eigenft)
}
alpha <- 1e+4
f.data_alpha <- matrix(0, nrow = 26, ncol = 1600)
for (i in 1:26){
f.data_alpha[i,] <- f_alpha_approx(f.data$ausxSL$data[i,],alpha,lambda,eigenft)
}
View(f.data_alpha)
Mahalanobis_Distance <- matrix(0, nrow = 26, ncol = 26)
View(alpha_Mahalanobis)
for (i in 1:26){
for (j in 1:26){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data$ausxSL$data[i,],f.data$ausxSL$data[j,],lambda,eigenft)
}
}
Mahalanobis_Distance <- matrix(0, nrow = 26, ncol = 26)
for (i in 1:26){
print(i)
for (j in 1:26){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data_alpha[i,],f.data_alpha[j,],lambda,eigenft)
}
}
View(Mahalanobis_Distance)
x11()
image.plot(1:26,1:26,Mahalanobis_Distance)
x11()
image.plot(1:26,1:26,Mahalanobis_Distance)
##### Save Workspace ####
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/BayesianProject")
save.image("functional_WP.RData")
library(fda.usc)
library(fda)
library(fields)
library(roahd)
# Commentate i set delle directory non vostre
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/BayesianProject")
n <- 100
c <- 15
t_points <- 200
data <- matrix(0, nrow = n, ncol = t_points)
cov_M1 <- function(s,t){
K <- 0.3 * exp(-abs(s - t)/0.3)
return(K)
}
time <- seq(0,1,1/(t_points-1))
K_1 <- matrix(0, nrow = t_points, ncol = t_points)
for (i in 1:t_points){
for (j in 1:t_points){
K_1[i,j] <- cov_M1(time[i],time[j])
}
}
m <- rep(0,t_points)
random_process <- generate_gauss_fdata(n, m, Cov = K_1)
n <- 26
c <- 10
t_points <- 200
data <- matrix(0, nrow = n, ncol = t_points)
cov_M1 <- function(s,t){
K <- 0.3 * exp(-abs(s - t)/0.3)
return(K)
}
time <- seq(0,1,1/(t_points-1))
K_1 <- matrix(0, nrow = t_points, ncol = t_points)
for (i in 1:t_points){
for (j in 1:t_points){
K_1[i,j] <- cov_M1(time[i],time[j])
}
}
m <- rep(0,t_points)
random_process <- generate_gauss_fdata(n, m, Cov = K_1)
main_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t * (1-t)^(3/2)
}
cont_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t^(3/2) * (1-t)
}
for (i in 1:(n-c)){
for (j in 1:t_points){
data[i,j] <- main_proc(time[j],t_points)
}
}
for (i in (n-c+1):n){
for (j in 1:t_points){
data[i,j] <- cont_proc(time[j],t_points)
}
}
data1 <- matrix(0, nrow = n, ncol = t_points)
for (i in 1:n){
for (j in 1:t_points){
data1[i,j] <- data[i,j] + random_process[i,j]
}
}
x11()
plot(time,data[1,],type = 'l', ylim = c(-2,7.5))
for(i in 2:16){
lines(time,data1[i,],type = 'l', col = 'firebrick2',lwd = 2)
}
for (i in 17:n){
lines(time,data1[i,],type = 'l', col = 'blue', lwd = 3)
}
View(data)
x11()
plot(time,data1[1,],type = 'l', ylim = c(-2,7.5), col = 'firebrick2', lwd = 2)
for(i in 2:16){
lines(time,data1[i,],type = 'l', col = 'firebrick2',lwd = 2)
}
for (i in 17:n){
lines(time,data1[i,],type = 'l', col = 'blue', lwd = 2)
}
alpha <- 1e+4
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = 26, ncol = t_points)
for (i in 1:26){
f.data_alpha_sim[i,] <- f_alpha_approx(f.data$ausxSL$data[i,],alpha,lambda,eigenft)
}
# approximation of the function f with f_alpha
f_alpha_approx <-function(f,alpha,lambda,eigenft){
coeff<-prod<-res<-rep(0,t_points)
approx<-matrix(0,t_points,t_points)
for (j in 1:t_points) {
coeff[j]<-lambda[j]/(lambda[j]+alpha)
prod[j]<-scalar_prod(f,eigenft[,j])
approx[,j]<- as.numeric(coeff[j]*prod[j])*eigenft[,j]
res<-res+approx[,j]
}
return(res)
}
#### alpha-Mahalanobis distance and other usefull functions ####
# functions
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
#calcolo la distanza al quadrato
alpha_Mahalanobis <- function(alpha,f1,f2,lambda, eigenft) {
dis<-coeff<-prod<-rep(0,t_points)
for (j in 1:t_points){
coeff[j]<-lambda[j]/(lambda[j]+alpha)^2
prod[j]<-(scalar_prod(f1-f2,eigenft[,j]))^2
dis[j]<-coeff[j]*prod[j]
}
res<-sum(dis)
return(res)
}
eig <- eigen(K_1)
values <- eig$values
vectors <- eig$vectors
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = 26, ncol = t_points)
for (i in 1:26){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,lambda,eigenft)
}
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = 26, ncol = t_points)
for (i in 1:26){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,values,vectors)
}
Mahalanobis_Distance <- matrix(0, nrow = 26, ncol = 26)
for (i in 1:26){
for (j in 1:26){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data_alpha_sim[i,],f.data_alpha_sim[j,],values,vectors)
}
}
x11()
image.plot(1:26,1:26,Mahalanobis_Distance)
m <- rep(0,t_points)
random_process <- generate_gauss_fdata(n, m, Cov = K_1)
main_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t * (1-t)^(3/2)
}
cont_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t^(3/2) * (1-t) - 1
}
for (i in 1:(n-c)){
for (j in 1:t_points){
data[i,j] <- main_proc(time[j],t_points)
}
}
for (i in (n-c+1):n){
for (j in 1:t_points){
data[i,j] <- cont_proc(time[j],t_points)
}
}
data1 <- matrix(0, nrow = n, ncol = t_points)
for (i in 1:n){
for (j in 1:t_points){
data1[i,j] <- data[i,j] + random_process[i,j]
}
}
# Simulated data plot
x11()
plot(time,data1[1,],type = 'l', ylim = c(-2,7.5), col = 'firebrick2', lwd = 2)
for(i in 2:16){
lines(time,data1[i,],type = 'l', col = 'firebrick2',lwd = 2)
}
for (i in 17:n){
lines(time,data1[i,],type = 'l', col = 'blue', lwd = 2)
}
#### alpha-Mahalanobis distance calculation ####
# Smoothed data
eig <- eigen(K_1)
values <- eig$values
vectors <- eig$vectors
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = 26, ncol = t_points)
for (i in 1:26){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,values,vectors)
}
# alpha-Mahalanobis distance matrix
Mahalanobis_Distance <- matrix(0, nrow = 26, ncol = 26)
for (i in 1:26){
for (j in 1:26){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data_alpha_sim[i,],f.data_alpha_sim[j,],values,vectors)
}
}
x11()
image.plot(1:26,1:26,Mahalanobis_Distance)
library(fda.usc)
library(fda)
library(fields)
library(roahd)
# Commentate i set delle directory non vostre
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/BayesianProject")
#setwd("C:/Users/admin/Documents/R/Project_BS/potenziali_evocati")
#### DATA SIMULATION - MODEL 1 ####
n <- 100
c <- 15
t_points <- 200
data <- matrix(0, nrow = n, ncol = t_points)
cov_M1 <- function(s,t){
K <- 0.3 * exp(-abs(s - t)/0.3)
return(K)
}
# Covariance Matrix
time <- seq(0,1,1/(t_points-1))
K_1 <- matrix(0, nrow = t_points, ncol = t_points)
for (i in 1:t_points){
for (j in 1:t_points){
K_1[i,j] <- cov_M1(time[i],time[j])
}
}
# Create simulated data
m <- rep(0,t_points)
random_process <- generate_gauss_fdata(n, m, Cov = K_1)
main_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t * (1-t)^(3/2)
}
cont_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t^(3/2) * (1-t)
}
for (i in 1:(n-c)){
for (j in 1:t_points){
data[i,j] <- main_proc(time[j],t_points)
}
}
for (i in (n-c+1):n){
for (j in 1:t_points){
data[i,j] <- cont_proc(time[j],t_points)
}
}
data1 <- matrix(0, nrow = n, ncol = t_points)
for (i in 1:n){
for (j in 1:t_points){
data1[i,j] <- data[i,j] + random_process[i,j]
}
}
# Simulated data plot
x11()
plot(time,data1[1,],type = 'l', ylim = c(-2,7.5), col = 'firebrick2', lwd = 2)
for(i in 2:(n-c)){
lines(time,data1[i,],type = 'l', col = 'firebrick2',lwd = 2)
}
for (i in (n-c+1):n){
lines(time,data1[i,],type = 'l', col = 'blue', lwd = 2)
}
eig <- eigen(K_1)
values <- eig$values
vectors <- eig$vectors
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = 26, ncol = t_points)
for (i in 1:n){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,values,vectors)
}
# approximation of the function f with f_alpha
f_alpha_approx <-function(f,alpha,lambda,eigenft){
coeff<-prod<-res<-rep(0,t_points)
approx<-matrix(0,t_points,t_points)
for (j in 1:t_points) {
coeff[j]<-lambda[j]/(lambda[j]+alpha)
prod[j]<-scalar_prod(f,eigenft[,j])
approx[,j]<- as.numeric(coeff[j]*prod[j])*eigenft[,j]
res<-res+approx[,j]
}
return(res)
}
#### alpha-Mahalanobis distance and other usefull functions ####
# functions
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
#calcolo la distanza al quadrato
alpha_Mahalanobis <- function(alpha,f1,f2,lambda, eigenft) {
dis<-coeff<-prod<-rep(0,t_points)
for (j in 1:t_points){
coeff[j]<-lambda[j]/(lambda[j]+alpha)^2
prod[j]<-(scalar_prod(f1-f2,eigenft[,j]))^2
dis[j]<-coeff[j]*prod[j]
}
res<-sum(dis)
return(res)
}
eig <- eigen(K_1)
values <- eig$values
vectors <- eig$vectors
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = 26, ncol = t_points)
for (i in 1:n){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,values,vectors)
}
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = n, ncol = t_points)
for (i in 1:n){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,values,vectors)
}
Mahalanobis_Distance <- matrix(0, nrow = 26, ncol = 26)
for (i in 1:n){
for (j in 1:n){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data_alpha_sim[i,],f.data_alpha_sim[j,],values,vectors)
}
}
Mahalanobis_Distance <- matrix(0, nrow = n, ncol = n)
for (i in 1:n){
for (j in 1:n){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data_alpha_sim[i,],f.data_alpha_sim[j,],values,vectors)
}
}
x11()
image.plot(1:n,1:n,Mahalanobis_Distance)
library(fda.usc)
library(fda)
library(fields)
# Commentate i set delle directory non vostre
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati")
setwd('C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/potenziali_evocati')
load('functional_WP.RData')
#### alpha-Mahalanobis distance and other usefull functions ####
# functions
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
# Compute eigenvalues and eigenfunctions of the covariance matrix
eigenvf<-eigen(K_hat)
lambda<-eigenvf$values
eigenft<-eigenvf$vectors
#calcolo la distanza al quadrato
alpha_Mahalanobis <- function(alpha,f1,f2,lambda, eigenft) {
dis<-coeff<-prod<-rep(0,t_points)
for (j in 1:t_points){
coeff[j]<-lambda[j]/(lambda[j]+alpha)^2
prod[j]<-(scalar_prod(f1-f2,eigenft[,j]))^2
dis[j]<-coeff[j]*prod[j]
}
res<-sum(dis)
return(res)
}
# approximation of the function f with f_alpha
f_alpha_approx <-function(f,alpha,lambda,eigenft){
coeff<-prod<-res<-rep(0,t_points)
approx<-matrix(0,t_points,t_points)
for (j in 1:t_points) {
coeff[j]<-lambda[j]/(lambda[j]+alpha)
prod[j]<-scalar_prod(f,eigenft[,j])
approx[,j]<- as.numeric(coeff[j]*prod[j])*eigenft[,j]
res<-res+approx[,j]
}
return(res)
}
# norm and inner product wrt sample covariance function K
norm2_K <- function (f,lambda,eigenft){
norm_vect<-prod<-rep(0,t_points)
for (j in 1:t_points){
prod[j]<-(scalar_prod(f,eigenft[,j]))^2
norm_vect[j]<-prod[j]/lambda[j]
}
res<-sum(norm_vect)
return(res)
}
inner_product_K<- function(f,g,lambda,eigenft) {
prod_vect<-prod_f<-prod_g<-rep(0,t_points)
for (j in 1:t_points){
prod_f[j]<-(scalar_prod(f,eigenft[,j]))
prod_g[j]<-(scalar_prod(g,eigenft[,j]))
norm_vect[j]<-prod_f[j]*prod_g[j]/lambda[j]
}
res<-sum(norm_vect)
return(res)
}
alpha <- 1e+4
f.data_alpha <- matrix(0, nrow = 26, ncol = 1600)
for (i in 1:26){
f.data_alpha[i,] <- f_alpha_approx(f.data$ausxSL$data[i,],alpha,lambda,eigenft)
}
Mahalanobis_Distance <- matrix(0, nrow = 26, ncol = 26)
for (i in 1:26){
print(i)
for (j in 1:26){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,f.data$ausxSL$data[i,],f.data$ausxSL$data[j,],lambda,eigenft)
}
}
x11()
image.plot(1:26,1:26,Mahalanobis_Distance)
##### Save Workspace ####
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/BayesianProject")
save.image("functional_WP.RData")
library(fda.usc)
library(fda)
library(fields)
library(roahd)
# Commentate i set delle directory non vostre
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/BayesianProject")
#setwd("C:/Users/admin/Documents/R/Project_BS/potenziali_evocati")
#### DATA SIMULATION - MODEL 1 ####
n <- 100
c <- 15
t_points <- 200
data <- matrix(0, nrow = n, ncol = t_points)
cov_M1 <- function(s,t){
K <- 0.3 * exp(-abs(s - t)/0.3)
return(K)
}
# Covariance Matrix
time <- seq(0,1,1/(t_points-1))
K_1 <- matrix(0, nrow = t_points, ncol = t_points)
for (i in 1:t_points){
for (j in 1:t_points){
K_1[i,j] <- cov_M1(time[i],time[j])
}
}
# Create simulated data
m <- rep(0,t_points)
random_process <- generate_gauss_fdata(n, m, Cov = K_1)
main_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t * (1-t)^(3/2)
}
cont_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t^(3/2) * (1-t)
}
for (i in 1:(n-c)){
for (j in 1:t_points){
data[i,j] <- main_proc(time[j],t_points)
}
}
for (i in (n-c+1):n){
for (j in 1:t_points){
data[i,j] <- cont_proc(time[j],t_points)
}
}
data1 <- matrix(0, nrow = n, ncol = t_points)
for (i in 1:n){
for (j in 1:t_points){
data1[i,j] <- data[i,j] + random_process[i,j]
}
}
# Simulated data plot
x11()
plot(time,data1[1,],type = 'l', ylim = c(-2,7.5), col = 'firebrick2', lwd = 2)
for(i in 2:(n-c)){
lines(time,data1[i,],type = 'l', col = 'firebrick2',lwd = 2)
}
for (i in (n-c+1):n){
lines(time,data1[i,],type = 'l', col = 'blue', lwd = 2)
}
#### alpha-Mahalanobis distance calculation ####
# Smoothed data
eig <- eigen(K_1)
values <- eig$values
vectors <- eig$vectors
alpha <- 1e+4
f.data_alpha_sim <- matrix(0, nrow = n, ncol = t_points)
for (i in 1:n){
f.data_alpha_sim[i,] <- f_alpha_approx(data1[i,],alpha,values,vectors)
}
# alpha-Mahalanobis distance matrix
Mahalanobis_Distance <- matrix(0, nrow = n, ncol = n)
for (i in 1:n){
for (j in 1:n){
Mahalanobis_Distance[i,j] <- alpha_Mahalanobis(alpha,data1[i,],data1[j,],values,vectors)
}
}
x11()
image.plot(1:n,1:n,Mahalanobis_Distance)
