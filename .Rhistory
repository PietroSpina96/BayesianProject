<<<<<<< HEAD
?
library(readxl)
dmr_data <- read_excel("C:/Users/pietr/Desktop/Pietro/Lavoro dmr/PPScore Data V2 - Copia.xlsx")
View(dmr_data)
dmr_data1 <- dmr_data;
attach(dmr_data1)
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (njs);
emed_js = c(ENG_RATE);
eadvmed_js = c(ADV_ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:Bs){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
pairs(~FOLLOWERS+REAL_PEOPLE_PERC+POSTS+ENG_RATE+ADV_ENG_RATE+FASHION_AUDIENCE_PERC)
vmed_js = seq(0,0,length.out = Bs);
for (i in 1:Bs){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS MEDIE";
dmr_data1 = dmr_data;
attach(dmr_data1);
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (njs);
emed_js = c(ENG_RATE);
eadvmed_js = c(ADV_ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:Bs){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
pairs(~FOLLOWERS+REAL_PEOPLE_PERC+POSTS+ENG_RATE+ADV_ENG_RATE+FASHION_AUDIENCE_PERC)
vmed_js = seq(0,0,length.out = Bs);
for (i in 1:Bs){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS MEDIE";
dmr_data1 = dmr_data;
attach(dmr_data1);
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (n_js);
emed_js = c(ENG_RATE);
eadvmed_js = c(ADV_ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:B_s){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
pairs(~FOLLOWERS+REAL_PEOPLE_PERC+POSTS+ENG_RATE+ADV_ENG_RATE+FASHION_AUDIENCE_PERC)
vmed_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS MEDIE";
View(dmr_data1)
colnames(dmr_data1)[9] <- "VIEWS_MEDIE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100));
}
v_
vrate_js
)
dmr_data
end
close
}
dmr_data1[140]
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)))*100;
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[9] <- "VIEWS_RATE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)))*100;
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[10] <- "VIEWS_RATE";
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS_MEDIE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)))*100;
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[10] <- "VIEWS_RATE";
pairs(~REAL_PEOPLE_PERC+ENG_RATE+VIEWS_RATE+FASHION_AUDIENCE_PERC)
dmr_data1 = dmr_data;
attach(dmr_data1);
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (n_js);
emed_js = c(ENG_RATE);
eadvmed_js = c(ADV_ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:B_s){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
pairs(~FOLLOWERS+REAL_PEOPLE_PERC+POSTS+ENG_RATE+ADV_ENG_RATE+FASHION_AUDIENCE_PERC)
vmed_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS_MEDIE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)))*100;
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[10] <- "VIEWS_RATE";
pairs(~REAL_PEOPLE_PERC+ENG_RATE+VIEWS_RATE+FASHION_AUDIENCE_PERC)
attach(dmr_data1)
pairs(~REAL_PEOPLE_PERC+ENG_RATE+VIEWS_RATE+FASHION_AUDIENCE_PERC)
attach(dmr_data1)
pairs(~REAL_PEOPLE_PERC+ENG_RATE+ADV_ENG_RATE+VIEWS_RATE+FASHION_AUDIENCE_PERC)
203295*56.11/100
effadv_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
effadv_js[i] = (VIEWS_RATE[i]*FASHION_AUDIENCE_PERC[i])*100;
}
dmr_data1[[11]] = effadv_js
colnames(dmr_data1)[11] <- "EFF_ADV_RATE"
effadv_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
effadv_js[i] = ((VIEWS_RATE[i]/100)*FASHION_AUDIENCE_PERC[i])*100;
}
dmr_data1[[11]] = effadv_js
colnames(dmr_data1)[11] <- "EFF_ADV_RATE"
dmr_data1 = dmr_data;
attach(dmr_data1);
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (n_js);
emed_js = c(ENG_RATE);
eadvmed_js = c(ADV_ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:B_s){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
vmed_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS_MEDIE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)));
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[10] <- "VIEWS_RATE";
vmedfash_js = seq(0,0,length.out = B_s);
efffash_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmedfash_js[i] = VIEWS_MEDIE[i] * FASHION_AUDIENCE_PERC[i];
}
for (i in 1:B_s){
efffash_js[i] = (vmedfash_js[i]/(FOLLOWERS[i]*REAL_PEOPLE_PERC[i]))*100;
}
dmr_data1[[11]] = vmedfash_js;
dmr_data1[[12]] = efffash_js;
colnames(dmr_data1)[11] = "FASHION_VIEWS_MEDIE";
colnames(dmr_data1)[12] = "FASHION_EFF_RATE";
attach(dmr_data1);
dmr_data2 = dmr_data1;
dmr_data2$ADV_ENG_RATE[which(is.na(dmr_data2$ADV_ENG_RATE) == T)] = 0;
emedadv_js = c(dmr_data2$ADV_ENG_RATE);
emaxadv_js = max (emedadv_js);
vadv_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vadv_js[i] = FOLLOWERS[i]*(emedadv_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emedadv_js[i]/emaxadv_js)*(1 - emedadv_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)
}
vadvfash_js = seq(0,0,length(B_s));
for (i in 1:B_s){
vadvfash_js[i] = vadv_js[i] * FASHION_AUDIENCE_PERC[i];
}
effadvfash_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
effadvfash_js[i] = (vadvfash_js[i]/(FOLLOWERS[i] * REAL_PEOPLE_PERC[i])) * 100;
}
dmr_data2[13] = vadv_js;
dmr_data2[14] = vadvfash_js;
dmr_data2[15] = effadvfash_js;
colnames(dmr_data2)[13] = "ADV_VIEWS_MEDIE";
colnames(dmr_data2)[14] = "FASHION_ADV_VIEWS_MEDIE";
colnames(dmr_data2)[15] = "FASHION_ADV_EFF_RATE";
attach(dmr_data2)
write.csv2(dmr_data2, file = "DMR_data.csv", quote = F, na = "", row.names = T, col.names = T);
getwd()
View(dmr_data2)
dmr_data1 = dmr_data;
attach(dmr_data1);
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (n_js);
emed_js = c(ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:B_s){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
vmed_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS_MEDIE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)));
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[10] <- "VIEWS_RATE";
vmedfash_js = seq(0,0,length.out = B_s);
efffash_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmedfash_js[i] = VIEWS_MEDIE[i] * FASHION_AUDIENCE_PERC[i];
}
for (i in 1:B_s){
efffash_js[i] = (vmedfash_js[i]/(FOLLOWERS[i]*REAL_PEOPLE_PERC[i]))*100;
}
dmr_data1[[11]] = vmedfash_js;
dmr_data1[[12]] = efffash_js;
colnames(dmr_data1)[11] = "FASHION_VIEWS_MEDIE";
colnames(dmr_data1)[12] = "FASHION_EFF_RATE";
attach(dmr_data1);
dmr_data2 = dmr_data1;
dmr_data2$ADV_ENG_RATE[which(is.na(dmr_data2$ADV_ENG_RATE) == T)] = 0;
emedadv_js = c(dmr_data2$ADV_ENG_RATE);
emaxadv_js = max (emedadv_js);
vadv_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vadv_js[i] = FOLLOWERS[i]*(emedadv_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emedadv_js[i]/emaxadv_js)*(1 - emedadv_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)
}
vadvfash_js = seq(0,0,length(B_s));
for (i in 1:B_s){
vadvfash_js[i] = vadv_js[i] * FASHION_AUDIENCE_PERC[i];
}
effadvfash_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
effadvfash_js[i] = (vadvfash_js[i]/(FOLLOWERS[i] * REAL_PEOPLE_PERC[i])) * 100;
}
dmr_data2[13] = vadv_js;
dmr_data2[14] = vadvfash_js;
dmr_data2[15] = effadvfash_js;
colnames(dmr_data2)[13] = "ADV_VIEWS_MEDIE";
colnames(dmr_data2)[14] = "FASHION_ADV_VIEWS_MEDIE";
colnames(dmr_data2)[15] = "FASHION_ADV_EFF_RATE";
attach(dmr_data2)
write.csv2(dmr_data2, file = "DMR_data.csv", quote = F, na = "", row.names = T, col.names = T);
dmr_data1 = dmr_data;
attach(dmr_data1);
n_s = sum (POSTS);
n_js = c(POSTS);
B_s = length (n_js);
emed_js = c(ENG_RATE);
emaxj_js = max(emed_js);
emedvec_s = seq(0,0,length.out = B_s);
for (i in 1:B_s){
emedvec_s[i] = (n_js[i]*emed_js[i])/n_s;
}
emed_s=sum(emedvec_s)
vmed_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmed_js[i] = FOLLOWERS[i]*(emed_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emed_js[i]/emaxj_js)*(1 - emed_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100);
}
dmr_data1[[9]] = vmed_js;
colnames(dmr_data1)[9] <- "VIEWS_MEDIE";
vrate_js=seq(0,0,length.out = B_s);
for (i in 1:B_s){
vrate_js[i] = (vmed_js[i]/(FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)));
}
dmr_data1[[10]] = vrate_js;
colnames(dmr_data1)[10] <- "VIEWS_RATE";
vmedfash_js = seq(0,0,length.out = B_s);
efffash_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vmedfash_js[i] = VIEWS_MEDIE[i] * FASHION_AUDIENCE_PERC[i];
}
for (i in 1:B_s){
efffash_js[i] = (vmedfash_js[i]/(FOLLOWERS[i]*REAL_PEOPLE_PERC[i]))*100;
}
dmr_data1[[11]] = vmedfash_js;
dmr_data1[[12]] = efffash_js;
colnames(dmr_data1)[11] = "FASHION_VIEWS_MEDIE";
colnames(dmr_data1)[12] = "FASHION_EFF_RATE";
attach(dmr_data1);
dmr_data2 = dmr_data1;
dmr_data2$ADV_ENG_RATE[which(is.na(dmr_data2$ADV_ENG_RATE) == T)] = 0;
emedadv_js = c(dmr_data2$ADV_ENG_RATE);
emaxadv_js = max (emedadv_js);
vadv_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
vadv_js[i] = FOLLOWERS[i]*(emedadv_js[i]/100)*(REAL_PEOPLE_PERC[i]/100) + (emedadv_js[i]/emaxadv_js)*(1 - emedadv_js[i]/100)*FOLLOWERS[i]*(REAL_PEOPLE_PERC[i]/100)
}
vadvfash_js = seq(0,0,length(B_s));
for (i in 1:B_s){
vadvfash_js[i] = vadv_js[i] * FASHION_AUDIENCE_PERC[i];
}
effadvfash_js = seq(0,0,length.out = B_s);
for (i in 1:B_s){
effadvfash_js[i] = (vadvfash_js[i]/(FOLLOWERS[i] * REAL_PEOPLE_PERC[i])) * 100;
}
dmr_data2[13] = vadv_js;
dmr_data2[14] = vadvfash_js;
dmr_data2[15] = effadvfash_js;
colnames(dmr_data2)[13] = "ADV_VIEWS_MEDIE";
colnames(dmr_data2)[14] = "FASHION_ADV_VIEWS_MEDIE";
colnames(dmr_data2)[15] = "FASHION_ADV_EFF_RATE";
attach(dmr_data2)
write.csv2(dmr_data2, file = "DMR_data.csv", quote = F, na = "", row.names = T, col.names = T);
View(dmr_data2)
getwd()
Sys.which("make")
install.packages("jsonlite", type = "source")
install.packages("cmdstanr", repos = c("https://mc-stan.org/r-packages/", getOption("repos")))
cmdstanr::install_cmdstan()
library(cmdstanr)
check_cmdstan_toolchain(fix=TRUE)
cmdstanr::install_cmdstan()
library(fda.usc)
library(fda)
library(fields)
# Commentate i set delle directory non vostre
setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/BayesianProject")
#setwd("C:/Users/admin/Documents/R/Project_BS/potenziali_evocati")
#### MODEL 1 ####
n <- 100
c <- 15
t_points <- 200
data <- matrix(0, nrow = n, ncol = t_points)
main_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t * (1-t)^(3/2) + rnorm(1,0,1)
}
time <- seq(0,1,1/(t_points-1))
for (i in 1:(n-c)){
for (j in 1:t_points){
data[i,j] <- main_proc(time[j],t_points)
}
}
cont_proc <- main_proc <- function(t,points){
X <- rep(0,points)
X[t] <- 30 * t^(3/2) * (1-t) + rnorm(1,0,1)
}
for (i in (n-c+1):n){
for (j in 1:t_points){
data[i,j] <- cont_proc(time[j],t_points)
}
}
x11()
plot(time,data[1,],type = 'l')
for(i in 2:200){
lines(time,data[i,],type = 'l')
}
x11()
plot(time,data[1,],type = 'l')
for(i in 2:100){
lines(time,data[i,],type = 'l')
}
cov_M1 <- function(s,t){
K <- 0.3 * exp(-abs(s - t)/0.3)
}
=======
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=5
M <- 750 # truncation level   M=500
Y <- vector(length=M) ## beta proportions in the stick breaking construction
tau <-  vector(length=M) ## support points
V <- vector(length=M)
# Simulation
Y <- rbeta(M,1,a) #simulation of the beta rvs
tau <- rnorm(M,0,1) # tau_i iid from alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##summation of the weights V
V <- V/sum(V)  ## Rinormalization of the weights
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=5")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){   #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T)
##
a=50
M <- 750 # livello di troncamento   M=500
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)  ## Rinormalizzo i V
oth <- order(tau)
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,xlab="",ylab="",cex.axis=1.5)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col="red",lwd=3)
title("Total mass a=50")
gra=gray(1:100/100)
gra=rep(gra,10)
for(j in 1:50){    #for(j in 1:100){
set.seed(j)
Y <- rbeta(M,1,a)
tau <- rnorm(M,0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod
print(sum(V))
V <- V/sum(V)
oth <- order(tau)
lines(c(min(tau)-100,tau[oth],max(tau)+100),c(0,cumsum(V[oth]),1),type="s",col=gra[j])
}
curve(pnorm(x,0,1),from=-4,to=4,col="magenta",lwd=2,add=T,xlab="",ylab="",cex.axis=1.5)
a=1
M <- 100 # livello di troncamento   M=30
Y <- vector(length=M) ##Il vettore V conterrà le v.a. beta della costruzione stick breaking
tau <-  vector(length=M) ## i punti di supporto della mpa processo di Dirichlet - PRIMA li abbiamo chiamati theta
V <- vector(length=M)
# Simulo
Y <- rbeta(M,1,a) #simulo le beta
tau <- rnorm(M,0,1) # simulo i tau in modo iid da alpha_0= N(0,1)
cprod <- cumprod(1-Y)
cprod  <- c(1,cprod[1:M-1])
V <- Y*cprod ## "spezzo i bastoncini" utilizzando le Y prima sumulate
print(sum(V))  ##Valuto la somma dei V
V <- V/sum(V)
round(V,4)
n=10 ## sample size
theta<-vector(length=n)
index <-vector(length=n)
for(j in 1:n){
index[j] <- sample(1:M,size=1,prob=V)
theta[j]=tau[index[j]]
}
index
theta
unique(theta)
help("sample")
# Commentate i set delle directory non vostre
#setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati")
#setwd('C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/potenziali_evocati')
setwd("C:/Users/admin/Documents/R/Project_BS/BayesianProject") #GiuliaR
library(fda.usc)
library(fda)
library(fields)
n <- 26
t_points <- 1600
X_bar <- colMeans(f.data$ausxSL$data) # functional mean
setwd("C:/Users/admin/Documents/R/Project_BS/potenziali_evocati")
# Load analisi_dati environment
load("~/R/Project_BS/potenziali_evocati/analisi_dati_env.RData")
# Load this one instead of running the K_hat matrix, run the t_points and then go to line 56
load("~/R/Project_BS/potenziali_evocati/alpha_mahalanobis_env.RData")
n <- 26
t_points<-1600
X_bar <- colMeans(f.data$ausxSL$data) # functional mean
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
# Compute eigenvalues and eigenfunctions of the covariance matrix
eigenvf<-eigen(K_hat)
lambda<-eigenvf$values
eigenft<-eigenvf$vectors
# prova
coeff1<-lambda[1]/(lambda[1]+alpha=0.001)
# prova
coeff1<-lambda[1]/(lambda[1]+0.001)
coeff2<-lambda[2]/(lambda[2]+0.001)
eigenfft[,1]
eigenft[,1]
help("eigen")
prod1<-scalar_prod(X_bar,eigenft[,1])
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
prod1<-scalar_prod(X_bar,eigenft[,1])
prod2<-scalar_prod(X_bar,eigenft[,2])
approx1<- (coeff1*prod1)*eigenft[,1]
approx2<- (coeff1*prod1)*eigenft[,2]
approx
approx1
dim(approx1)
nrow(approx1)
length(approx1)
approx1[,1]
res<-rep(0,t_points)
res1<-res+approx1
res2<-res1+approx2
# Load analisi_dati environment
load("~/R/Project_BS/potenziali_evocati/analisi_dati_env.RData")
# Load this one instead of running the K_hat matrix, run the t_points and then go to line 56
load("~/R/Project_BS/potenziali_evocati/alpha_mahalanobis_env.RData")
n <- 26
t_points<-1600
X_bar <- colMeans(f.data$ausxSL$data) # functional mean
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
alpha_Mahalanobis <- function(alpha,f1,f2,lambda, eigenft) {
#calcolo la distanza al quadrato
dis<-coeff<-prod<-rep(0,t_points)
for (j in 1:t_points){
coeff[j]<-lambda[j]/(lambda[j]+alpha)^2
prod[j]<-(scalar_prod(f1-f2,eigenft[,j]))^2
dis[j]<-coeff[j]*prod[j]
}
res<-sum(dis)
return(res)
}
f_alpha_approx <-function(f,alpha,lambda,eigenft){
coeff<-prod<-res<-rep(0,t_points)
approx<-matrix(0,t_points,t_points)
for (j in 1:t_points) {
coeff[j]<-lambda[j]/(lambda[j]+alpha)
prod[j]<-scalar_prod(f,eigenft[,j])
approx[,j]<- (coeff[j]*prod[j])*eigenft[,j]
res<-res+approx[,j]
}
return(res)
}
norm2_K <- function (f,lambda,eigenft){
norm_vect<-prod<-rep(0,t_points)
for (j in 1:t_points){
prod[j]<-(scalar_prod(f,eigenft[,j]))^2
norm_vect[j]<-prod[j]/lambda[j]
}
res<-sum(norm_vect)
return(res)
}
inner_product_K<- function(f,g,lambda,eigenft) {
prod_vect<-prod_f<-prod_g<-rep(0,t_points)
for (j in 1:t_points){
prod_f[j]<-(scalar_prod(f,eigenft[,j]))
prod_g[j]<-(scalar_prod(g,eigenft[,j]))
norm_vect[j]<-prod_f[j]*prod_g[j]/lambda[j]
}
res<-sum(norm_vect)
return(res)
}
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=1e-8,lambda,eigenft)
eigenvf<-eigen(K_hat)
lambda<-eigenvf$values
eigenft<-eigenvf$vectors
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=1e-8,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=1e-4,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=1e-3,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=1,lambda,eigenft)
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=100,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha=100,lambda,eigenft)
f_prova_alpha<-f_alpha_approx(f_prova,alpha=1e-8,lambda,eigenft)
alpha<-1e-4
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
alpha<-1e-1
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha,lambda,eigenft)
# OBS: from the theory we know that only (N-1) eigenvalues are not null where N=number of
# statistical units. Here we have N=26 and 25 not null eigenvalues.
lambda[1:26]
alpha<-1e+8
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
alpha<-1e+4
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha,lambda,eigenft)
alpha<-1e+5
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
setwd("C:/Users/admin/Documents/R/Project_BS/potenziali_evocati") #GiuliaR
n<-100
x_grid<-seq(0,1,length.out=50)
c<-0
mu0<-rep(0,length(x_grid))
main_function<-function (t,s,mu0) {
X_t<-30*t*((1-t)^(3/2)) + eps(t,s,mu0)
return (X_t)
}
contam_function <-function (t,s,mu0) {
Xc_t<-30*(t^(3/2))*(1-t) + eps(t,s,mu0)
return(Xc_t)
}
eps<-function (t,s,mu0) {
eps_t<-rnorm(1,mu0,cov_eps(t,s))
return(eps_t)
}
cov_eps<-function(t,s) {
cov_eps_ts<-(0.3)*exp(-abs(s-t)/(0.3))
return(cov_eps_ts)
}
K_hat <- matrix(0,length(x_grid),length(x_grid))
for (i in 1:length(x_grid)){
for (j in 1:length(x_grid)){
K_hat[i,j] <- cov_eps(i,j)
}
}
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
eigenvf<-eigen(K_hat)
lambda<-eigenvf$values
eigenft<-eigenvf$vectors
alpha_Mahalanobis <- function(alpha,f1,f2,lambda, eigenft) {
#calcolo la distanza al quadrato
dis<-coeff<-prod<-rep(0,t_points)
for (j in 1:t_points){
coeff[j]<-lambda[j]/(lambda[j]+alpha)^2
prod[j]<-(scalar_prod(f1-f2,eigenft[,j]))^2
dis[j]<-coeff[j]*prod[j]
}
res<-sum(dis)
return(res)
}
# approximation of the function f with f_alpha
t_points<-50
f_alpha_approx <-function(f,alpha,lambda,eigenft){
coeff<-prod<-res<-rep(0,t_points)
approx<-matrix(0,t_points,t_points)
for (j in 1:t_points) {
coeff[j]<-lambda[j]/(lambda[j]+alpha)
prod[j]<-scalar_prod(f,eigenft[,j])
approx[,j]<- (coeff[j]*prod[j])*eigenft[,j]
res<-res+approx[,j]
}
return(res)
}
# Rappresentazione di una sola simulazione
sample_eps<-eps(x_grid,x_grid,mu0)
main_sample<-main_function(x_grid,x_grid,mu0)
contam_sample<-contam_function(x_grid,x_grid,mu0)
x11()
plot(x_grid,main_sample,col='blue',type='l',ylim=c(-1,10))
lines(x_grid,contam_sample,col='green')
sample_eps_vect<-main_sample_vec<-contam_sample_vec<-matrix(0,n,length(x_grid))
for (i in 1:n) {
sample_eps_vect[i,]<-eps(x_grid,x_grid,mu0)
main_sample_vec[i,]<-main_function(x_grid,x_grid,mu0)
contam_sample_vec[i,]<-contam_function(x_grid,x_grid,mu0)
}
mean_main_sample<-colMeans(main_sample_vec)
mean_contam_sample<-colMeans(contam_sample_vec)
alpha<-1e-5
mean_main_sample_alpha<-f_alpha_approx(mean_main_sample,alpha,lambda,eigenft)
main_sample_vec_alpha<-f_alpha_approx(main_sample_vec[1,],alpha,lambda,eigenft)
x11()
plot(x_grid,main_sample_vec_alpha,col='blue',type='l',ylim=c(-1,10))
lines(x_grid,main_sample_vec[1,],col='green')
# calcolo le alpha_approssimazioni
alpha<-1e-5
mean_main_sample_alpha<-f_alpha_approx(mean_main_sample,alpha,lambda,eigenft)
main_sample_vec_alpha<-f_alpha_approx(main_sample_vec[1,],alpha,lambda,eigenft)
x11()
plot(x_grid,main_sample_vec_alpha,col='blue',type='l',ylim=c(-1,10))
lines(x_grid,main_sample_vec[1,],col='green')
x11()
plot(x_grid,main_sample_vec_alpha,col='blue',type='l',ylim=c(-1,10))
alpha<-1e-3
mean_main_sample_alpha<-f_alpha_approx(mean_main_sample,alpha,lambda,eigenft)
main_sample_vec_alpha<-f_alpha_approx(main_sample_vec[1,],alpha,lambda,eigenft)
x11()
plot(x_grid,main_sample_vec_alpha,col='blue',type='l',ylim=c(-1,10))
lines(x_grid,main_sample_vec[1,],col='green')
alpha<-1e-1
mean_main_sample_alpha<-f_alpha_approx(mean_main_sample,alpha,lambda,eigenft)
main_sample_vec_alpha<-f_alpha_approx(main_sample_vec[1,],alpha,lambda,eigenft)
x11()
plot(x_grid,main_sample_vec_alpha,col='blue',type='l',ylim=c(-1,10))
lines(x_grid,main_sample_vec[1,],col='green')
# Commentate i set delle directory non vostre
#setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati")
#setwd('C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/potenziali_evocati')
setwd("C:/Users/admin/Documents/R/Project_BS/BayesianProject") #GiuliaR
load('functional_WP.RData')
setwd("C:/Users/admin/Documents/R/Project_BS/potenziali_evocati")
# Load analisi_dati environment
load("~/R/Project_BS/potenziali_evocati/analisi_dati_env.RData")
# Load this one instead of running the K_hat matrix, run the t_points and then go to line 56
load("~/R/Project_BS/potenziali_evocati/alpha_mahalanobis_env.RData")
n <- 26
t_points<-1600
X_bar <- colMeans(f.data$ausxSL$data) # functional mean
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
kernel_estimator <- function(process,med,n,s,t){
est <- rep(0,t_points)
for (i in 1:n) {
est[i] <- (process[i,s] - med[s])*(process[i,t] - med[t])
}
estimator = (1/n)*sum(est)
return(estimator)
}
kernel_estimator(f.data$ausxSL$data,X_bar,n,1,9) # prova
# Plot of the covariance matrix
time<-seq(1,t_points)
scalar_prod<- function (f1,f2) {
# f sono vettori colonna
res<- t(f1)%*%f2
return(res)
}
eigenvf<-eigen(K_hat)
lambda<-eigenvf$values
eigenft<-eigenvf$vectors
alpha_Mahalanobis <- function(alpha,f1,f2,lambda, eigenft) {
#calcolo la distanza al quadrato
dis<-coeff<-prod<-rep(0,t_points)
for (j in 1:t_points){
coeff[j]<-lambda[j]/(lambda[j]+alpha)^2
prod[j]<-(scalar_prod(f1-f2,eigenft[,j]))^2
dis[j]<-coeff[j]*prod[j]
}
res<-sum(dis)
return(res)
}
f_alpha_approx <-function(f,alpha,lambda,eigenft){
coeff<-prod<-res<-rep(0,t_points)
approx<-matrix(0,t_points,t_points)
for (j in 1:t_points) {
coeff[j]<-lambda[j]/(lambda[j]+alpha)
prod[j]<-scalar_prod(f,eigenft[,j])
approx[,j]<- (coeff[j]*prod[j])*eigenft[,j]
res<-res+approx[,j]
}
return(res)
}
norm2_K <- function (f,lambda,eigenft){
norm_vect<-prod<-rep(0,t_points)
for (j in 1:t_points){
prod[j]<-(scalar_prod(f,eigenft[,j]))^2
norm_vect[j]<-prod[j]/lambda[j]
}
res<-sum(norm_vect)
return(res)
}
inner_product_K<- function(f,g,lambda,eigenft) {
prod_vect<-prod_f<-prod_g<-rep(0,t_points)
for (j in 1:t_points){
prod_f[j]<-(scalar_prod(f,eigenft[,j]))
prod_g[j]<-(scalar_prod(g,eigenft[,j]))
norm_vect[j]<-prod_f[j]*prod_g[j]/lambda[j]
}
res<-sum(norm_vect)
return(res)
}
alpha<-1e+5
f_prova<-X_bar
f_prova_alpha<-f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
save.image("~/R/Project_BS/potenziali_evocati/functional_WP.RData")
load("~/R/Project_BS/potenziali_evocati/functional_WP.RData")
# Commentate i set delle directory non vostre
#setwd("C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati")
#setwd('C:/Users/pietr/Desktop/Bayesian Statistics/Progetto/dati/potenziali_evocati')
setwd("C:/Users/admin/Documents/R/Project_BS/BayesianProject") #GiuliaR
load('functional_WP.RData')
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
for(i in 1:26){
lines(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[i,], lwd=1)
}
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
alpha<-1e+5
f_prova <- X_bar
f_prova_alpha <- f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
alpha<-1e+8
f_prova <- X_bar
f_prova_alpha <- f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
alpha<-1e+5
f_prova <- X_bar
f_prova_alpha <- f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
alpha<-1e+4
f_prova <- X_bar
f_prova_alpha <- f_alpha_approx(f_prova,alpha,lambda,eigenft)
x11()
plot(t(importMatrix(res, type = c('SL', 'sx'), position = 'au'))[1,], type = "l", ylim = c(-250, 250))
lines(f.data$ausxSL$argvals, X_bar, type = 'l', lwd=3, col = 'firebrick2')
lines(f.data$ausxSL$argvals, f_prova_alpha, type = 'l', lwd=3, col = 'blue')
>>>>>>> b7d5226092a3489aeb97090c5ce4344e6bd1eb9b
